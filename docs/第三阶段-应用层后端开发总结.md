# 第三阶段：应用层后端开发总结

## 一、阶段目标

基于Django框架开发RESTful API后端服务，实现数据接入、模型调用、日志存储、预警逻辑等核心功能，为前端可视化提供数据支撑。

## 二、技术栈

| 技术 | 版本 | 用途 |
|------|------|------|
| Django | 4.2.27 | Web框架 |
| Django REST Framework | 3.16.1 | RESTful API |
| Channels | 4.3.2 | WebSocket支持 |
| SQLite | - | 开发数据库 |
| django-cors-headers | 4.9.0 | 跨域支持 |

## 三、项目架构

### 3.1 分层架构设计

```
backend/
├── config/                     # 项目配置层
│   ├── settings.py            # Django配置
│   ├── urls.py                # 主路由配置
│   ├── asgi.py                # ASGI配置（WebSocket）
│   └── wsgi.py                # WSGI配置
├── common/                     # 公共模块
│   ├── exceptions.py          # 自定义异常类
│   └── response.py            # 统一响应格式
├── devices/                    # 设备管理模块
│   ├── models.py              # 数据模型
│   ├── services/              # 业务逻辑层
│   │   └── device_service.py
│   ├── serializers.py         # 序列化器
│   ├── views.py               # API视图
│   └── urls.py                # 路由配置
├── detection/                  # 异常检测模块
│   ├── models.py              # 数据模型
│   ├── services/              # 业务逻辑层
│   │   ├── detection_service.py
│   │   └── model_service.py   # 模型服务
│   ├── consumers.py           # WebSocket消费者
│   ├── routing.py             # WebSocket路由
│   ├── serializers.py         # 序列化器
│   ├── views.py               # API视图
│   └── urls.py                # 路由配置
├── logs/                       # 日志告警模块
│   ├── models.py              # 数据模型
│   ├── services/              # 业务逻辑层
│   │   ├── alert_service.py
│   │   └── log_service.py
│   ├── serializers.py         # 序列化器
│   ├── views.py               # API视图
│   └── urls.py                # 路由配置
└── scripts/                    # 工具脚本
    └── init_test_data.py      # 测试数据初始化
```

### 3.2 代码分层原则

| 层级 | 职责 | 文件 |
|------|------|------|
| **Models** | 数据模型定义 | `models.py` |
| **Services** | 业务逻辑处理 | `services/*.py` |
| **Serializers** | 数据序列化/验证 | `serializers.py` |
| **Views** | API接口处理 | `views.py` |
| **URLs** | 路由配置 | `urls.py` |

## 四、数据模型设计

### 4.1 设备模型 (Device)

```python
class Device(models.Model):
    device_id = models.CharField('设备ID', max_length=64, unique=True)
    name = models.CharField('设备名称', max_length=128)
    device_type = models.CharField('设备类型', choices=[
        ('camera', '智能摄像头'),
        ('door_lock', '智能门锁'),
        ('sensor', '传感器'),
        ('gateway', '网关'),
        ('other', '其他')
    ])
    ip_address = models.GenericIPAddressField('IP地址')
    status = models.CharField('状态', choices=[
        ('online', '在线'),
        ('offline', '离线'),
        ('warning', '告警')
    ])
    is_trusted = models.BooleanField('是否可信')
    last_seen = models.DateTimeField('最后在线时间')
```

### 4.2 检测记录模型 (DetectionRecord)

```python
class DetectionRecord(models.Model):
    device_id = models.CharField('设备ID', max_length=64)
    timestamp = models.DateTimeField('检测时间')
    src_ip = models.GenericIPAddressField('源IP')
    dst_ip = models.GenericIPAddressField('目的IP')
    protocol = models.CharField('协议', max_length=10)
    # 流量特征
    duration = models.FloatField('持续时间')
    orig_bytes = models.BigIntegerField('发送字节数')
    resp_bytes = models.BigIntegerField('接收字节数')
    # 检测结果
    is_anomaly = models.BooleanField('是否异常')
    attack_type = models.CharField('攻击类型', choices=[
        ('normal', '正常'),
        ('ddos', 'DDoS攻击'),
        ('port_scan', '端口扫描'),
        ('unauthorized', '越权访问'),
        ('malformed', '异常指令')
    ])
    confidence = models.FloatField('置信度')
    inference_time = models.FloatField('推理耗时(ms)')
```

### 4.3 告警日志模型 (AlertLog)

```python
class AlertLog(models.Model):
    device_id = models.CharField('设备ID', max_length=64)
    level = models.CharField('告警级别', choices=[
        ('info', '信息'),
        ('warning', '警告'),
        ('danger', '危险'),
        ('critical', '严重')
    ])
    status = models.CharField('处理状态', choices=[
        ('pending', '待处理'),
        ('confirmed', '已确认'),
        ('resolved', '已解决'),
        ('ignored', '已忽略')
    ])
    attack_type = models.CharField('攻击类型')
    title = models.CharField('告警标题')
    description = models.TextField('告警描述')
    confidence = models.FloatField('置信度')
    alert_time = models.DateTimeField('告警时间')
```

## 五、RESTful API设计

### 5.1 设备管理API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/v1/devices/` | 获取设备列表（支持筛选） |
| POST | `/api/v1/devices/` | 创建新设备 |
| GET | `/api/v1/devices/{device_id}/` | 获取设备详情 |
| PUT | `/api/v1/devices/{device_id}/` | 更新设备信息 |
| DELETE | `/api/v1/devices/{device_id}/` | 删除设备 |
| GET | `/api/v1/devices/overview/` | 获取设备概览统计 |
| POST | `/api/v1/devices/{device_id}/update_status/` | 更新设备状态 |

### 5.2 异常检测API

| 方法 | 路径 | 说明 |
|------|------|------|
| POST | `/api/v1/detection/detect/` | 单条数据检测 |
| POST | `/api/v1/detection/batch/` | 批量数据检测 |
| POST | `/api/v1/detection/upload/` | 上传CSV文件检测 |
| GET | `/api/v1/detection/records/` | 获取检测记录列表 |
| GET | `/api/v1/detection/records/{id}/` | 获取检测记录详情 |
| GET | `/api/v1/detection/stats/` | 获取检测统计数据 |
| GET | `/api/v1/detection/tasks/` | 获取检测任务列表 |
| GET | `/api/v1/detection/model-info/` | 获取模型信息 |

### 5.3 日志告警API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/v1/logs/alerts/` | 获取告警列表 |
| GET | `/api/v1/logs/alerts/{id}/` | 获取告警详情 |
| PATCH | `/api/v1/logs/alerts/{id}/` | 更新告警状态 |
| POST | `/api/v1/logs/alerts/batch-update/` | 批量更新告警状态 |
| GET | `/api/v1/logs/alerts/stats/` | 获取告警统计 |
| GET | `/api/v1/logs/system/` | 获取系统日志 |

### 5.4 WebSocket接口

| 路径 | 说明 |
|------|------|
| `ws://host/ws/detection/` | 实时检测结果推送 |

**消息格式：**
```json
// 客户端发送检测请求
{"action": "detect", "data": {...}}

// 服务端推送检测结果
{"type": "detection_result", "data": {...}}

// 服务端推送告警
{"type": "alert", "data": {...}}
```

## 六、统一响应格式

```json
{
    "code": 200,
    "message": "success",
    "data": {
        // 业务数据
    }
}
```

**分页响应格式：**
```json
{
    "code": 200,
    "message": "success",
    "data": {
        "count": 100,
        "next": "http://api/v1/xxx/?page=2",
        "previous": null,
        "results": [...]
    }
}
```

## 七、核心服务实现

### 7.1 模型服务 (ModelService)

```python
class ModelService:
    """模型管理服务（单例模式）"""
    
    def load_model(self, model_path):
        """加载模型文件"""
        
    def predict(self, features):
        """单条样本预测"""
        return {
            'is_anomaly': bool,
            'attack_type': str,
            'confidence': float,
            'anomaly_score': float,
            'inference_time': float,
            'model_version': str
        }
    
    def predict_batch(self, features_batch):
        """批量预测"""
```

### 7.2 检测服务 (DetectionService)

```python
class DetectionService:
    """异常检测服务"""
    
    @staticmethod
    def detect_single(data):
        """单条数据检测"""
        
    @staticmethod
    def detect_batch(data_list):
        """批量数据检测"""
        
    @staticmethod
    def detect_from_csv(file_path, task_id):
        """从CSV文件批量检测"""
        
    @staticmethod
    def get_statistics(days=7):
        """获取检测统计数据"""
```

### 7.3 告警服务 (AlertService)

```python
class AlertService:
    """告警管理服务"""
    
    @staticmethod
    def create_alert_from_detection(record, result):
        """根据检测结果创建告警"""
        
    @staticmethod
    def update_alert_status(alert_id, status):
        """更新告警状态"""
        
    @staticmethod
    def get_alert_statistics(days=7):
        """获取告警统计"""
```

## 八、测试数据

已创建测试数据：
- 7个智能家居设备（摄像头、门锁、传感器、网关）
- 100条检测记录（约20%异常）
- 20条告警记录

## 九、启动方式

```bash
# 进入项目目录
cd /path/to/Lite-SH-Anomaly

# 激活虚拟环境
source venv/bin/activate

# 进入后端目录
cd backend

# 数据库迁移
python manage.py migrate

# 初始化测试数据（可选）
python scripts/init_test_data.py

# 启动开发服务器
python manage.py runserver 8000
```

## 十、API测试示例

### 10.1 单条检测

```bash
curl -X POST http://localhost:8000/api/v1/detection/detect/ \
  -H "Content-Type: application/json" \
  -d '{
    "device_id": "CAM-001",
    "src_ip": "192.168.1.100",
    "dst_ip": "192.168.1.101",
    "protocol": "TCP",
    "duration": 0.5,
    "orig_bytes": 1024,
    "resp_bytes": 2048,
    "orig_pkts": 10,
    "resp_pkts": 15
  }'
```

### 10.2 获取设备列表

```bash
curl http://localhost:8000/api/v1/devices/
```

### 10.3 获取检测统计

```bash
curl http://localhost:8000/api/v1/detection/stats/?days=7
```

## 十一、后续衔接

后端API已就绪，将为第四阶段Vue前端开发提供数据接口支持。前端将通过以下方式与后端交互：

1. **HTTP请求**：调用RESTful API获取数据
2. **WebSocket**：订阅实时检测结果推送
3. **文件上传**：上传CSV文件进行批量检测
